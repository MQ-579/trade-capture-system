1. TradeControllerTest debugging:
1a. fix(test): TradeControllerTest - Fixed testDeleteTrade endpoint validation
- Problem Description:
 The test was expecting a response code of 204, which means no content. While the correct response code was 200, which means successfull.
- Root Cause Analysis: 
 The test was expecting wrong response code from the endpoint.
- Solution Implemented: 
 Replaced the method "isNotContent" with "isOk". 
- Verification: 
 I ran the test again and the log file showed that the failure count reduced by 1.

1b. fixed(test): TradeControllerTest - Fixed testCreateTrade endpoint validation
- Problem Description:
 The test expected status 400 bad request, but controller returned 200 successfull. The controller did not detect the mismatch and proceeded to call the service normally.
- Root Cause Analysis:
 The Controller was overriding (tradeDTO.setTradeId(id)) instead of validating it. Meaning the mismatch check never happens.
- Solution Implemented:
 Added explicit check to return 400 Bad Request if path ID differs from request body ID. Thus validate that the path ID matches the DTO ID and reject the request.
- Verification: 
 I ran mvn -Dtest=TradeControllerTest test, the test passed and the log file showed that the failure count reduced by 1.

 1c. fixed(test): TradeControllerTest - Fixed testUpdateTrade endpoint validation
- Problem Description:
 The test expected status 200 isOk, but controller returned 201 created, the correct response code.
- Root Cause Analysis:
 The method in TradeContollerTest did not match with the method in TradeController. The test was expecting wrong response code from the endpoint
- Solution Implemented:
 Updated the method "isOk" with "isCreated" so it matches the method in TradeController.
- Verification: 
 I ran mvn clean test the testUpdateTradeIdMismatch() passed and the log file showed that the failure count reduced by 1.

 1d. fix(test): TradeControllerTest - Fixed testCreateTradeValidationFailure endpoint

- Problem: The testCreateTradeValidationFailure_MissingBook was failing because the createTrade() endpoint returned a 201 (Created) response instead of the expected 400 (Bad Request) when the bookName field was missing in the trade creation request.
- Root Cause: The createTrade() method in TradeController did not include validation logic for missing bookName and counterpartyName fields.
  Although @Valid was used to trigger bean validation, these fields were not annotated with @NotNull or similar constraints in the TradeDTO, allowing the method to proceed with saving the trade and returning a 201 status even when required data was missing.
- Solution: Added validation inside the createTrade() method to check whether both bookName and counterpartyName are present before proceeding.
  If either field is missing, the method now returns a 400 Bad Request with the message "Book and Counterparty are required".
- Verification: I ran mvn clean test the testCreateTradeValidationFailure_MissingBook passed successfully and the log file showed that the failure count reduced by 2.
  The endpoint now correctly returns HTTP 400 with the expected response message when required fields are missing.

1e. fix(test): TradeControllerTest - Fixed testCreateTradeValidationFailure_MissingTradeDate
- Problem: The unit test testCreateTradeValidationFailure_MissingTradeDate was failing. This test aimed to confirm that when a user attempts to create a trade without providing the required tradeDate, the server returns a specific, custom error message: "Trade date is required". Instead of this custom message, the test received a generic 400 Bad Request response, and the response body was empty.
- Root Cause: The issue occurred because the @Valid annotation on the createTrade() method in TradeController triggered Spring’s automatic validation before the request reached the controller’s custom validation logic. As a result, the method never executed the if checks that returned the descriptive error messages, leading to an empty 400 Bad Request response.
- Solution: Removed the @Valid annotation from the createTrade() method to ensure that manual validation logic within the method executes for missing fields. This approach allows the controller to return the expected custom error messages that align with the test assertions. This solution was chosen to precise control over validation responses and maintain the expected user facinf error format.
- Verification: I ran mvn clean test the testCreateTradeValidationFailure_MissingTradeDate passed successfully. Confirmed that the API returns the correct error messages in the response body when the respective fields are missing.

1f. fix(test): TradeControllerTest - Fixed testUpdateTrade()
- Problem: TradeControllerTest.testUpdateTrade() was failing with Wanted but not invoked because it attempted to verify a method (saveTrade()) that was no longer called in the controller.
- Root Cause: The TradeController.updateTrade() method was refactored to call tradeService.amendTrade() instead of saveTrade(). The test class, however, was not updated to reflect this change, causing the verification mismatch.
- Solution: Replaced all references to saveTrade() in the test with amendTrade(). Updated the mocking and verification logic to ensure the test matches the controller’s current behavior.
- Verification: I ran mvn clean test. testUpdateTrade() now passes successfully, confirming that tradeService.amendTrade() is being called as expected.

1g. fix(test): TradeControllerTest - TradeController Validation Order
- Problem: When testing the createTrade() endpoint, the validation order caused misleading error responses. If both the tradeDate and bookName were missing, the system returned “Book and Counterparty are required” instead of “Trade date is required”. This led to confusion and failed test assertions expecting the correct priority of validation errors.
- Root Cause: The createTrade() method in TradeController performed the Book and Counterparty validation before checking for a missing Trade Date. As a result, the first validation block returned prematurely, preventing the system from identifying and reporting the actual missing trade date field.
- Solution: The validation sequence was reordered so that Trade Date is now validated first before Book and Counterparty fields. This ensures that trade creation requests with missing tradeDate return the correct and most relevant validation error message. This change aligns validation flow with logical business rules, date validity is fundamental before party and book details.
- Verification: After implementing the fix, I ran mvn clean test and all affected unit tests in TradeControllerTest, particularly testCreateTradeValidationFailure_MissingTradeDate(), passed successfully.

2. fix(test): TradeLegControllerTest - Fixed trade leg creation DTO validation
- Problem: testCreateTradeLegValidationFailure_NegativeNotional() was failing with an empty response body instead of returning "Notional must be positive".
- Root Cause: The @Positive annotation on the TradeLegDTO triggered Bean Validation before reaching the controller, and the default Spring error handler returned an empty 400 Bad Request response body.
- Solution: Removed @Valid to the TradeLegRequestDTO in TradeLegController.createTradeLeg
- Verification: I ran mvn clean test, the testCreateTradeLegValidationFailure_NegativeNotional() test now passes successfully.
The API returns the explicit message "Notional must be positive" when a negative notional value is submitted.